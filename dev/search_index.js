var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Constructs","category":"page"},{"location":"#Constructs","page":"Home","title":"Constructs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Constructs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Constructs]","category":"page"},{"location":"#Constructs.Constructs","page":"Home","title":"Constructs.Constructs","text":"A declarative de-ser for binary data. Inspired by Construct.\n\n\n\n\n\n","category":"module"},{"location":"#Constructs.Float16be","page":"Home","title":"Constructs.Float16be","text":"Float16be = BigEndian(Float16)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.Float16le","page":"Home","title":"Constructs.Float16le","text":"Float16le = LittleEndian(Float16)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.Float32be","page":"Home","title":"Constructs.Float32be","text":"Float32be = BigEndian(Float32)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.Float32le","page":"Home","title":"Constructs.Float32le","text":"Float32le = LittleEndian(Float32)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.Float64be","page":"Home","title":"Constructs.Float64be","text":"Float64be = BigEndian(Float64)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.Float64le","page":"Home","title":"Constructs.Float64le","text":"Float64le = LittleEndian(Float64)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.Int128be","page":"Home","title":"Constructs.Int128be","text":"Int128be = BigEndian(Int128)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.Int128le","page":"Home","title":"Constructs.Int128le","text":"Int128le = LittleEndian(Int128)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.Int16be","page":"Home","title":"Constructs.Int16be","text":"Int16be = BigEndian(Int16)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.Int16le","page":"Home","title":"Constructs.Int16le","text":"Int16le = LittleEndian(Int16)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.Int32be","page":"Home","title":"Constructs.Int32be","text":"Int32be = BigEndian(Int32)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.Int32le","page":"Home","title":"Constructs.Int32le","text":"Int32le = LittleEndian(Int32)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.Int64be","page":"Home","title":"Constructs.Int64be","text":"Int64be = BigEndian(Int64)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.Int64le","page":"Home","title":"Constructs.Int64le","text":"Int64le = LittleEndian(Int64)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.UInt128be","page":"Home","title":"Constructs.UInt128be","text":"UInt128be = BigEndian(UInt128)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.UInt128le","page":"Home","title":"Constructs.UInt128le","text":"UInt128le = LittleEndian(UInt128)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.UInt16be","page":"Home","title":"Constructs.UInt16be","text":"UInt16be = BigEndian(UInt16)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.UInt16le","page":"Home","title":"Constructs.UInt16le","text":"UInt16le = LittleEndian(UInt16)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.UInt32be","page":"Home","title":"Constructs.UInt32be","text":"UInt32be = BigEndian(UInt32)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.UInt32le","page":"Home","title":"Constructs.UInt32le","text":"UInt32le = LittleEndian(UInt32)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.UInt64be","page":"Home","title":"Constructs.UInt64be","text":"UInt64be = BigEndian(UInt64)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.UInt64le","page":"Home","title":"Constructs.UInt64le","text":"UInt64le = LittleEndian(UInt64)\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.this","page":"Home","title":"Constructs.this","text":"this\n\nPlaceholder to access properties of the current object in @construct context.\n\n\n\n\n\n","category":"constant"},{"location":"#Constructs.AbstractConstructError","page":"Home","title":"Constructs.AbstractConstructError","text":"AbstractConstructError <: Exception\n\nAbstract error type for constructs.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.Adapter","page":"Home","title":"Constructs.Adapter","text":"Adapter{TSub, T} <: Wrapper{TSub, T}\n\nAbstract adapter type.\n\nMethods\n\nsubcon(adapter::Adapter{TSub, T})::Construct{TSub}\nencode(adapter::Adapter{TSub, T}, obj::T; contextkw...)\ndecode(adapter::Adapter{TSub, T}, obj::TSub; contextkw...)\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.BigEndian","page":"Home","title":"Constructs.BigEndian","text":"BigEndian{T, TSubCon<:Construct{T}} <: Adapter{T, T}\n\nBig endian data adapter for serializing and deserializing.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.BigEndian-Union{Tuple{Type{T}}, Tuple{T}} where T<:Union{Float16, Float32, Float64, Int128, Int16, Int32, Int64, UInt128, UInt16, UInt32, UInt64}","page":"Home","title":"Constructs.BigEndian","text":"BigEndian(type)\n\nDefines the big endian format type.\n\nExamples\n\njulia> deserialize(BigEndian(UInt16), b\"\\x12\\x34\")\n0x1234\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.Const","page":"Home","title":"Constructs.Const","text":"Const{T, TSubCon<:Construct{T}, VT} <: Validator{T}\n\nField enforcing a constant.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.Const-Union{Tuple{VT}, Tuple{T}, Tuple{Type{T}, VT}} where {T, VT}","page":"Home","title":"Constructs.Const","text":"Const([base,] value)\n\nDefines a constant value, usually used for file headers.\n\nArguments\n\nbase::Union{Type, Construct}: the underlying type/construct.\nvalue: the expected value.\n\nExamples\n\njulia> serialize(Const(0x01), 0x01)\n1-element Vector{UInt8}:\n 0x01\n\njulia> deserialize(Const(0x01), b\"\\x01\")\n0x01\n\njulia> serialize(Const(0x01), 0x03)\nERROR: ValidationError: 3 mismatch the const value 1.\n[...]\n\njulia> deserialize(Const(0x01), b\"\\x02\")\nERROR: ValidationError: 2 mismatch the const value 1.\n[...]\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.Construct","page":"Home","title":"Constructs.Construct","text":"Construct{T}\n\nConstruct is used for serializing and deserializing objects.\n\nMethods\n\ndeserialize(cons::Construct{T}, s::IO; contextkw...)::T\nserialize(cons::Construct{T}, s::IO, obj::T; contextkw...)\nestimatesize(cons::Construct{T}; contextkw...) - optional\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.Construct-Tuple{Construct}","page":"Home","title":"Constructs.Construct","text":"Construct(type)\n\nGet default construct for type.\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.ConstructSize","page":"Home","title":"Constructs.ConstructSize","text":"ConstructSize\n\nAbstract super type of construct size.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.Container","page":"Home","title":"Constructs.Container","text":"Container{T}\n\nIntermediate container for a struct object when serializing/deserializing it.\n\nContainer{T}()\n\nCreate an uninitialized container for T.\n\nExamples\n\njulia> Container{Complex{Int64}}()\nContainer{Complex{Int64}}:\n  re: #undef\n  im: #undef\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.Container-Tuple{T} where T","page":"Home","title":"Constructs.Container","text":"Container(object)\n\nCreate a container from object.\n\nExamples\n\njulia> Container(3+4im)\nContainer{Complex{Int64}}:\n  re: Int64 = 3\n  im: Int64 = 4\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.EnumExhaustive","page":"Home","title":"Constructs.EnumExhaustive","text":"EnumExhaustive <: EnumExhaustibility\n\nIndicates the enumeration is exhaustive.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.EnumNonExhaustive","page":"Home","title":"Constructs.EnumNonExhaustive","text":"EnumNonExhaustive <: EnumExhaustibility\n\nIndicates the enumeration is non-exhaustive.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.ExactSize","page":"Home","title":"Constructs.ExactSize","text":"ExactSize(value)\n\nExact construct size (upper bound and lower bound are same).\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.ExceedMaxIterations","page":"Home","title":"Constructs.ExceedMaxIterations","text":"ExceedMaxIterations(msg, [max_iter])\n\nError thrown when exceed the max iterations.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.GreedyVector","page":"Home","title":"Constructs.GreedyVector","text":"GreedyVector{T, TSubCon<:Construct{T}} <: Repeater{T, 1, Vector{T}}\n\nHomogenous array of elements for unknown count of elements by deserializing until end of stream.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.GreedyVector-Tuple{Type}","page":"Home","title":"Constructs.GreedyVector","text":"GreedyVector(element)\n\nDefines an unknown-sized vector, which will deserialize elements as much as possible.\n\nArguments\n\nelement::Union{Type, Construct}: the type/construct of elements.\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.IntEnum","page":"Home","title":"Constructs.IntEnum","text":"IntEnum{Ex<:EnumExhaustibility, T, TSubCon<:Construct{T}, E<:Base.Enum} <: Adapter{T, E}\n\nInteger-based enum adapter for serializing and deserializing.\n\nThis is the default constructor for Base.Enum{T}.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.IntEnum-Union{Tuple{E}, Tuple{TSubCon}, Tuple{T}, Tuple{Ex}, Tuple{TSubCon, Type{E}}} where {Ex, T<:Integer, TSubCon<:Construct{T}, E<:Enum}","page":"Home","title":"Constructs.IntEnum","text":"IntEnum{EnumNonExhaustive}([base,] enum)\n\nDefines the non-exhaustive enum.\n\nArguments\n\nbase::Union{Type, Construct}: the base integer type/construct.\nenum::Type: the enum type.\n\nExamples\n\njulia> @enum Fruit::UInt8 apple=1 banana=2 orange=3\n\njulia> deserialize(IntEnum{EnumNonExhaustive}(Fruit), b\"\\x04\")\n<invalid #4>::Fruit = 0x04\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.IntEnum-Union{Tuple{E}, Tuple{Union{Construct, Type}, Type{E}}} where E<:Enum","page":"Home","title":"Constructs.IntEnum","text":"IntEnum([base,] enum)\n\nDefines the (exhaustive) enum.\n\nArguments\n\nbase::Union{Type, Construct}: the base integer type/construct.\nenum::Type: the enum type.\n\nExamples\n\njulia> @enum Fruit::UInt8 apple=1 banana=2 orange=3\n\njulia> deserialize(IntEnum(Fruit), b\"\\x02\")\nbanana::Fruit = 0x02\n\njulia> deserialize(IntEnum(Fruit), b\"\\x04\")\nERROR: ArgumentError: invalid value for Enum Fruit: 4\n[...]\n\njulia> serialize(IntEnum(UInt16le, Fruit), orange)\n2-element Vector{UInt8}:\n 0x03\n 0x00\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.JuliaSerializer","page":"Home","title":"Constructs.JuliaSerializer","text":"JuliaSerializer <: Construct{Any}\n\nStandard Julia serialization.\n\nSee also: Serialization\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.LittleEndian","page":"Home","title":"Constructs.LittleEndian","text":"LittleEndian{T, TSubCon<:Construct{T}} <: Adapter{T, T}\n\nLittle endian data adapter for serializing and deserializing.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.LittleEndian-Union{Tuple{Type{T}}, Tuple{T}} where T<:Union{Float16, Float32, Float64, Int128, Int16, Int32, Int64, UInt128, UInt16, UInt32, UInt64}","page":"Home","title":"Constructs.LittleEndian","text":"LittleEndian(type)\n\nDefines the little endian format type.\n\nExamples\n\njulia> deserialize(LittleEndian(UInt16), b\"\\x12\\x34\")\n0x3412\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.Padded","page":"Home","title":"Constructs.Padded","text":"Padded{T, TSubCon<:Construct{T}} <: Wrapper{T, T}\n\nRepresents Padded data.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.PaddedError","page":"Home","title":"Constructs.PaddedError","text":"PaddedError(msg)\n\nError thrown when the encoded string or bytes takes more bytes than padding allows, or the pad value is improper.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.PrimitiveIO","page":"Home","title":"Constructs.PrimitiveIO","text":"PrimitiveIO{T} <: Construct{T}\n\nConstruct based on primitive read/write.\n\nThis is the default construct for Bool, Char, UInt8, UInt16, UInt32, UInt64, UInt128, Int8, Int16, Int32, Int64, Int128, Float16, Float32 and Float64.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.PrimitiveIO-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"Constructs.PrimitiveIO","text":"PrimitiveIO(type)\n\nDefines a primitive IO construct for type.\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.PropertyPath","page":"Home","title":"Constructs.PropertyPath","text":"PropertyPath(segments)\n\nRepresents a property path.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.RaiseError","page":"Home","title":"Constructs.RaiseError","text":"RaiseError{E<:Exception} <: Construct{Union{}}\n\nHelper to raise an user-defined error.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.RaiseError-Tuple{AbstractString}","page":"Home","title":"Constructs.RaiseError","text":"RaiseError(error::Exception)\nRaiseError(message::String)\n\nRaise specific error or ErrorException(message) when serializing or deserializing any data.\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.RangedSize","page":"Home","title":"Constructs.RangedSize","text":"RangedSize(lower, upper)\n\nRanged construct size.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.Repeater","page":"Home","title":"Constructs.Repeater","text":"Repeater{T, N, TA<:AbstractArray{T,N}} <: Wrapper{T, TA}\n\nAbstract base type for Array wrapper.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.Sequence","page":"Home","title":"Constructs.Sequence","text":"Sequence{Tuple{Ts...}} <: Construct{Tuple{Ts...}}\n\nA sequence of construct data.\n\nThis is the default constructor for Tuple{Ts...}.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.Singleton","page":"Home","title":"Constructs.Singleton","text":"Singleton{T} <: Construct{T}\n\nSingleton type empty construct.\n\nThis is the default constructor for Nothing and Missing.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.SizedArray","page":"Home","title":"Constructs.SizedArray","text":"SizedArray{T, N, TA<:AbstractArray{T,N}, TSubCon<:Construct{T}} <: Repeater{T, N, TA}\n\nHomogenous array of elements.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.SizedArray-Union{Tuple{TSubCon}, Tuple{TA}, Tuple{N}, Tuple{T}, Tuple{Type{TA}, TSubCon, Vararg{Integer, N}}} where {T, N, TA<:AbstractArray, TSubCon<:Construct{T}}","page":"Home","title":"Constructs.SizedArray","text":"SizedArray([arraytype,] element, size...)\n\nDefines an array with specific size and element.\n\nArguments\n\narraytype::Type: the target array type, the default is Array{T, N}.\nelement::Union{Type, Construct}: the type/construct of elements.\nsize: the size of the array.\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.SymmetricAdapter","page":"Home","title":"Constructs.SymmetricAdapter","text":"SymmetricAdapter{T} <: Adapter{T, T}\n\nAbstract adapter type. encode both for serializing and deserializing.\n\nMethods\n\nsubcon(adapter::SymmetricAdapter{T})::Construct{T}\nencode(adapter::SymmetricAdapter{T}, obj::T; contextkw...)\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.Try","page":"Home","title":"Constructs.Try","text":"Try{TU} <: Construct{TU}\n\nAttempts to serialize/deserialize each of the subconstructs.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.UnboundedSize","page":"Home","title":"Constructs.UnboundedSize","text":"UnboundedSize(lower)\n\nUnbounded ranged size.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.UnboundedUpper","page":"Home","title":"Constructs.UnboundedUpper","text":"UnboundedUpper\n\nUnsigned infinity.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.UndefProperty","page":"Home","title":"Constructs.UndefProperty","text":"UndefProperty\n\nPlaceholder for undefined properties in Container.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.ValidationError","page":"Home","title":"Constructs.ValidationError","text":"ValidationError(msg)\n\nError thrown when the validatiion failed.\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.Validator","page":"Home","title":"Constructs.Validator","text":"Validator{T} <: SymmetricAdapter{T}\n\nAbstract validator type. Validates a condition on the encoded/decoded object..\n\nMethods\n\nsubcon(validator::Validator{T})::Construct{T}\nvalidate(validator::Validator{T}, obj::T; contextkw...)\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.Wrapper","page":"Home","title":"Constructs.Wrapper","text":"Wrapper{TSub, T} <: Construct{T}\n\nBase type of wrapper of TSub.\n\nMethods\n\nsubcon(wrapper::Wrapper{TSub, T})::Construct{TSub}\n\n\n\n\n\n","category":"type"},{"location":"#Constructs.decode","page":"Home","title":"Constructs.decode","text":"decode(adapter::Adapter{TSub, T}, obj::TSub; contextkw...) where {TSub, T}\n\n\n\n\n\n","category":"function"},{"location":"#Constructs.deserialize","page":"Home","title":"Constructs.deserialize","text":"deserialize(cons::Construct, s::IO; contextkw...)\ndeserialize(T, s::IO; contextkw...)\n\nDeserialize a stream to an object.\n\n\n\n\n\n","category":"function"},{"location":"#Constructs.deserialize-Tuple{Construct, AbstractString}","page":"Home","title":"Constructs.deserialize","text":"deserialize(cons::Construct, filename::AbstractString; contextkw...)\ndeserialize(T, filename::AbstractString; contextkw...)\n\nDeserialize a file to an object.\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.deserialize-Tuple{Construct, AbstractVector{UInt8}}","page":"Home","title":"Constructs.deserialize","text":"deserialize(cons::Construct, bytes::AbstractVector{UInt8}; contextkw...)\ndeserialize(T, bytes::AbstractVector{UInt8}; contextkw...)\n\nDeserialize a byte array to an object.\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.encode","page":"Home","title":"Constructs.encode","text":"encode(adapter::Adapter{TSub, T}, obj::T; contextkw...) where {TSub, T}\n\n\n\n\n\n","category":"function"},{"location":"#Constructs.estimatesize-Tuple{Construct}","page":"Home","title":"Constructs.estimatesize","text":"estimatesize(cons::Construct; contextkw...)\nestimatesize(T; contextkw...)\n\nEstimate the size of the type.\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.serialize","page":"Home","title":"Constructs.serialize","text":"serialize(cons::Construct, s::IO, obj; contextkw...)\nserialize(T, s::IO, obj; contextkw...)\nserialize(s::IO, obj; contextkw...)\n\nSerialize an object into a stream.\n\n\n\n\n\n","category":"function"},{"location":"#Constructs.serialize-Union{Tuple{T}, Tuple{Construct{T}, AbstractString, Any}} where T","page":"Home","title":"Constructs.serialize","text":"serialize(cons::Construct, filename::AbstractString, obj; contextkw...)\nserialize(T, filename::AbstractString, obj; contextkw...)\nserialize(filename::AbstractString, obj; contextkw...)\n\nSerialize an object to the file.\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.serialize-Union{Tuple{T}, Tuple{Construct{T}, Any}} where T","page":"Home","title":"Constructs.serialize","text":"serialize(cons::Construct, obj; contextkw...)\nserialize(T, obj; contextkw...)\nserialize(obj; contextkw...)\n\nSerialize an object in memory (a byte array).\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.serialize-Union{Tuple{T}, Tuple{Construct{T}, IO, UndefProperty}} where T","page":"Home","title":"Constructs.serialize","text":"serialize(cons::Construct, s::IO, ::UndefProperty; contextkw...)\n\nSerialize an insufficient object into a stream.\n\nNote\n\nThis method is usually called for anonymous fields in @construct.\n\nBy default, only singleton types support this because they don't need to write anything.\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.subcon-Tuple{Wrapper}","page":"Home","title":"Constructs.subcon","text":"subcon(wrapper::Wrapper{TSub, T})::Construct{TSub}\n\nGet sub-construct of wrapper.\n\n\n\n\n\n","category":"method"},{"location":"#Constructs.validate","page":"Home","title":"Constructs.validate","text":"validate(validator::Validator{T}, obj::T; contextkw...)\n\nChecks whether the given obj is a valid value for the validator.\n\nShould return a Bool or throw a ValidationError.\n\n\n\n\n\n","category":"function"},{"location":"#Constructs.@construct-Tuple{Expr}","page":"Home","title":"Constructs.@construct","text":"@construct [ConstructName] structdefinition\n\nGenerate a Construct subtype with ConstructName for the given struct.\n\nExamples\n\njulia> @construct struct Bitmap\n           ::Const(b\"BMP\")\n           width::UInt16le\n           height::UInt16le\n           pixel::SizedArray(UInt8, this.width, this.height)\n       end\n\njulia> deserialize(Bitmap, b\"BMP\\x03\\x00\\x02\\x00\\x01\\x02\\x03\\x04\\x05\\x06\")\nBitmap(0x0003, 0x0002, UInt8[0x01 0x04; 0x02 0x05; 0x03 0x06])\n\njulia> serialize(Bitmap(2, 3, UInt8[1 2 3; 7 8 9]))\n13-element Vector{UInt8}:\n 0x42\n 0x4d\n 0x50\n 0x02\n 0x00\n 0x03\n 0x00\n 0x01\n 0x07\n 0x02\n 0x08\n 0x03\n 0x09\n\njulia> estimatesize(Bitmap)\nUnboundedSize(0x0000000000000007)\n\n\n\n\n\n","category":"macro"}]
}
